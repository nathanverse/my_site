<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Syntax on Hugo ʕ•ᴥ•ʔ Bear Blog</title>
    <link>http://localhost:1313/blog/syntax/</link>
    <description>Recent content in Syntax on Hugo ʕ•ᴥ•ʔ Bear Blog</description>
    <generator>Hugo</generator>
    <language>en-US</language>
    <copyright>Copyright © 2020, Jane Doe.</copyright>
    <lastBuildDate>Wed, 08 Jan 2025 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/blog/syntax/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Thread scheduling</title>
      <link>http://localhost:1313/thread-scheduling/</link>
      <pubDate>Wed, 08 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/thread-scheduling/</guid>
      <description>&lt;p&gt;Threads perform tasks, which have priority itself. Therefore, threads usually have a priority number associated to it. A thread is inactive when:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;In call a block operation, &lt;code&gt;wait()&lt;/code&gt;, &lt;code&gt;sleep()&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;It is preempted, meaning the thread gives slot for another thread to run (a thread with higher priority, or because the current CPU cycles the current&#xA;thread allowed to use is exceeded)&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;⚠️ Warning:&lt;/strong&gt;&#xA;Use priority only to affect scheduling policy for efficiency. Do not rely on thread priority for algorithm correctness. Attempting to write&#xA;not thread-safe code by assuming the current thread can execute exclusively with higher priority, while there are other lower-prioritized threads&#xA;access to that code, would potentially fail.&lt;/p&gt;</description>
    </item>
    <item>
      <title>Deadlock</title>
      <link>http://localhost:1313/deadlock/</link>
      <pubDate>Tue, 07 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/deadlock/</guid>
      <description>&lt;p&gt;Deadlock is a phenomenon where two threads attempt to acquire two different objects&amp;rsquo; locks which can never be released because the locks are being&#xA;acquired by the other thread. This is well-known concept, I just put a code where deadlocks can be occurred, if you can detect&#xA;the sequences the deadlock can occur, you already grasped this concept well. Supposed we create two object&#xA;&lt;code&gt;Friendly&lt;/code&gt;, assigned their partners, and call &lt;code&gt;hug&lt;/code&gt; of each object on each thread:&lt;/p&gt;</description>
    </item>
    <item>
      <title>Thread terminnation</title>
      <link>http://localhost:1313/thread-terminnation/</link>
      <pubDate>Tue, 07 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/thread-terminnation/</guid>
      <description>&lt;p&gt;A thread terminates when:&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;The run method returns normally.&lt;/li&gt;&#xA;&lt;li&gt;The run method completes abruptly.&lt;/li&gt;&#xA;&lt;li&gt;The application terminates.&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;When a thread is terminated, all locks must be released, otherwise it would make other threads to wait forever.&lt;/p&gt;&#xA;&lt;p&gt;There is some case you would want a thread to take control the CPU for while, and then cancel it if you want.&#xA;For example, imagine a user &lt;code&gt;Cancel&lt;/code&gt; button is triggered while another thread is in a transaction,&#xA;making request to the database. You&amp;rsquo;d prefer the thread would be canceled after completely returning from the&#xA;transaction. In that case, following pattern is popular.&lt;/p&gt;</description>
    </item>
    <item>
      <title>wait, notifyAll, notify</title>
      <link>http://localhost:1313/wait-notifyall-notify/</link>
      <pubDate>Tue, 07 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/wait-notifyall-notify/</guid>
      <description>&lt;h1 id=&#34;wait-notifyall-notify&#34;&gt;wait, notifyAll, notify&lt;/h1&gt;&#xA;&lt;p&gt;In some circumstances, you might want a thread to notify another thread to do its work when some condition occurs. Example can be, you&#xA;have a &lt;code&gt;Print&lt;/code&gt; class, where people can add &lt;code&gt;PrintJob&lt;/code&gt;. You would to model thread like&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;A thread to receive job.&lt;/li&gt;&#xA;&lt;li&gt;A thread to do the job.&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;This model is efficient, because clients could receive a return immediately, and wait until their jobs get done.&lt;/p&gt;</description>
    </item>
    <item>
      <title>My New Post</title>
      <link>http://localhost:1313/my-new-post/</link>
      <pubDate>Mon, 06 Jan 2025 20:35:59 +0700</pubDate>
      <guid>http://localhost:1313/my-new-post/</guid>
      <description>&lt;p&gt;This is a page about »My New Post«.&lt;/p&gt;</description>
    </item>
    <item>
      <title>1. Synchronization</title>
      <link>http://localhost:1313/1.-synchronization/</link>
      <pubDate>Mon, 06 Jan 2025 00:00:00 +0000</pubDate>
      <guid>http://localhost:1313/1.-synchronization/</guid>
      <description>&lt;h1 id=&#34;java-synchronization&#34;&gt;Java Synchronization&lt;/h1&gt;&#xA;&lt;p&gt;In Java, concepts of synchronization are based on lock of objects.&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Adding synchronized modifier before a method&lt;/strong&gt;: if the method is an instance method, the class instance&amp;rsquo;s lock is acquire,&#xA;if the method is static, the java class object&amp;rsquo;s of the class is acquired&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Using synchronized block&lt;/strong&gt;: Lock can be acquired on any object given&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;Basically, you should acquire lock on the object if its states are accessed and modified by different threads.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
